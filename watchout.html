<html>
<head>
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.4.4/underscore-min.js" type="text/javascript"></script>
</head>
<body>
<div>Current Score: <span id='current-score'>0</span></div>
<div>Best Score: <span id='best-score'>0</span></div>
<div class='container'></div>
<script type="text/javascript">
  var gameOptions = {
    height: 450,
    width: 700,
    nEnemies: 30,
    padding: 20
  };
  var gameBoard = d3.select('.container').append('svg:svg')
                      .attr('width', gameOptions.width)
                      .attr('height', gameOptions.height);

  var gameStats = {
    score:0,
    bestScore:0
  };
  var axes = {
    x:d3.scale.linear().domain([0,100]).range([0, gameOptions.width]),
    y:d3.scale.linear().domain([0,100]).range([0, gameOptions.height])
  };


  var Player = function(gameOptions) {
    var output = {};
    output.gameOptions = gameOptions;

    var PlayerObj = {
      path: 'm-7.5,1.62413c0,-5.04095 4.08318,-9.12413 9.12414,-9.12413c5.04096,0 9.70345,5.53145 11.87586,9.12413c-2.02759,2.72372 -6.8349,9.12415 -11.87586,9.12415c-5.04096,0 -9.12414,-4.08318 -9.12414,-9.12415z',
      fill: '#ff6600',
      x: 0,
      y: 0,
      angle: 0,
      r: 5,
      constructor: function(gameOptions){
        this.gameOptions = gameOptions;
      },
      render: function(to){
        this.el = to.append('svg:path')
                    .attr('d', this.path)
                    .attr('fill', this.fill);
        this.transform({
          x: this.gameOptions.width * 0.5,
          y: this.gameOptions.height * 0.5
        });
        this.setupDragging();
        return this;
      },
      getX: function(){
        return this.x;
      },
      setX: function(x){
        var minX = this.gameOptions.padding;
        var maxX = this.gameOptions.width - this.gameOptions.padding;
        if(x <= minX){
          x = minX;
        }
        if(x >= maxX){
          x = maxX;
        }
        this.x = x;
      },
      getY: function(){
        return this.y;
      },
      setY: function(y){
        var minY = this.gameOptions.padding;
        var maxY = this.gameOptions.width - this.gameOptions.padding;
        if(y <= minY){
          y = minY;
        }
        if(y >= maxY){
          y = maxY;
        }
        this.y = y;
      },
      transform: function(opts){
        this.angle = opts.angle || this.angle;
        this.setX(opts.x || this.x);
        this.setY(opts.y || this.y);

        this.el.attr('transform', ("rotate(" + this.angle + "," + (this.getX()) + "," + (this.getY()) + ") ") + ("translate(" + (this.getX()) + "," + (this.getY()) + ")"));
      },
      // moveAbsolute: function(x,y) {
      //   this.transform({
      //     x: x,
      //     y: y
      //   });
      // },
      moveRelative: function(dx, dy) {
        this.transform({
          x: this.getX()+dx,
          y: this.getY()+dy,
          angle: 360 * (Math.atan2(dy,dx)/(Math.PI*2))
        });
      },
      setupDragging: function() {
        var that = this;
        var dragMove = function() {
          return that.moveRelative(d3.event.dx, d3.event.dy);
        };
        var drag = d3.behavior.drag()
                    .on('drag', dragMove);
        return this.el.call(drag);
      }
    };

    return _.extend(output, PlayerObj);
  };

  var players = [];
  var player1 = new Player(gameOptions);
  players.push( player1.render(gameBoard) );

  var createEnemies = function(){
    return _( _.range(0, gameOptions.nEnemies) ).map(function(i){
      return {
        id: i,
        x: Math.random() * 100,
        y: Math.random() * 100
      };
    });
  };

  var render = function(enemy_data){
    var enemies = gameBoard.selectAll('circle.enemy').data(enemy_data, function(d){
      return d.id;
    });

    enemies.enter()
      .append('svg:circle')
        .attr('class', 'enemy')
        .attr('cx', function(enemy){ return axes.x(enemy.x); })
        .attr('cy', function(enemy){ return axes.y(enemy.y); })
        .attr('r', 10);

    enemies.exit()
      .remove();

    var resetScore = function(){
      if (gameStats.score > gameStats.bestScore) {
        gameStats.bestScore = gameStats.score;
        d3.select('#best-score').text(gameStats.bestScore);
      }
      gameStats.score = 0;
    };

    var checkCollision = function(enemy){
      var sumRadius = parseFloat(enemy.attr('r')) + player1.r;
      var distance = Math.sqrt( Math.pow((enemy.attr('cx') - player1.getX()), 2) +
                                Math.pow((enemy.attr('cy') - player1.getY()), 2) );
      if(distance < sumRadius) {
        resetScore();
      }
    };

    var tweenWithCollisionDetection = function(endData) {
      var enemy = d3.select(this);
      var startPos = {
        x: parseFloat( enemy.attr('cx') ),
        y: parseFloat( enemy.attr('cy') )
      };
      var endPos = {
        x: axes.x(endData.x),
        y: axes.y(endData.y)
      };



      return function(t) {
        checkCollision(enemy);
        var enemyNextPos = {
          x: startPos.x + (endPos.x - startPos.x) * t,
          y: startPos.y + (endPos.y - startPos.y) * t
        };
        enemy.attr('cx', enemyNextPos.x)
             .attr('cy', enemyNextPos.y);
      };
    };

    enemies
      .transition()
        .duration(2000)
        .tween('custom', tweenWithCollisionDetection);


  };


  var gameTurn = function() {
    var enemyArray = createEnemies();
    render(enemyArray);
    setTimeout(gameTurn, 2000);
  };

  var increaseScore = function() {
    gameStats.score++;
    d3.select('#current-score').text(gameStats.score);
    setTimeout(increaseScore, 50);
  }

  gameTurn();
  increaseScore();



</script>
</body>
</html>